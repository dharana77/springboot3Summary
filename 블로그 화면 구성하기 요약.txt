타임리프는 템플릿 엔진임

템플릿엔진은 스프링 서버에서 데이터를 받아 웹페이지, HTML 상에 그 데이터를 넣어 보여주는 도구
다만 HTML과 템플릿 엔진을 위한 문법을 살짝 섞어 사용해야 함

아주 간단한 템플릿 문법
<h1 text=${이름}>
<p text=${나이}>

${이름}이 text 어트리뷰트로 할당되어 있음. p 태그도 비슷
이렇게 해 두면 서버에서 이름, 나이라는 키로 데이터를 템플릿 엔진에 넘겨주고 템플릿 엔진은 이를 받아 HTML에 값을 적용함

서버에서 보내준 데이터 예
{
    이름: "홍길동"
    나이 : 11
}

값이 달라지면 그때 그때 화면에 반영하니 동적인 웹 페이지를 만들 수 있게 되는 것

템플릿 엔진은 각각 문법이 미묘하게 달라서 템플릿 엔진마다 문법을 새로 배워야 함
대부분 구조는 비슷해서 한번 배워두면 다른 템플릿 엔진은 금방 익숙하게 다룰 수 있음

Q 개인적으로 궁금했던 점
템플릿 엔진은 왜 사용하는지
프론트 엔드 코드는 사용하면 되지 않는지? SSR이기 때문이라 사용?

-서치 결과
1. 많은 코드를 줄일 수 있다.
템플릿 엔진을 사용하면 기존의 HTML에 비하여 간단한 문법을 사용한다. 따라서 코드를 훨씬 간결하게 작성할 수 있다.
2. 재사용성이 높다.
웹 페이지는 똑같은 디자인의 페이지에 데이터만 바뀌는 경우가 매우 많다. 이럴 때 템플릿 엔진을 사용하면 미리 템플릿을 만들어 놓고 데이터를 바꿔가면서 수많은 페이지를 만들어 낼 수 있으므로 효율적이다.
3. 유지보수에 용이하다.
하나의 템플릿을 미리 만들어 놓고 관리하는 것은 수백개의 비슷한 모양의 HTML 페이지를 관리하는 것보다 훨씬 효율적이다.


타임리프 표현식 및 문법
${...} 변수의 값 표현식
#{...} 속성 파일 값 표현식
@{...} URL 표현식
*{...} 선택한 변수의 표현식. th:object에서 선택한 객체에 접근

타임리프 문법
th:text 텍스트를 표현할 때 사용 th:text${person.name}
th:each 컬렉션을 반복할 때 사용 th:each="person:${person}"
th:if 조건이 true 인 때만 표시 th:if="${person.age}>20"



====궁금해서 찾아본 결과들 및 답========
JSP란? 서블릿과 서블릿 컨테이너란?
JSP는 자바 언어를 기반으로 하는 서버 사이드 스크립트언어로
HTML 코드에 자바 코드를 넣어 동적인 웹페이지를 생성할 수 있음. 서블릿과 비슷한 역할으 함

서블릿이 자바 코드에 HTML 코드가 들어가는 형태라면, JSP는 html 코드에 자바 코드가 들어가는 구조임
JSP는 WAS에 의해 서블릿 클래스로 변환되어 사용됨
JSP는 WAS가 이미 만들어놓은 객체를 사용하며
사용자 정의 태그를 사용하여 보다 효율적으로 웹사이트를 구성함
HTML 코드안에 자바 코드가 있으므로 HTML 코드를 작성하기 쉬움
서블릿과 달리 JSP는 수정된 경우 재배포할 필요없이 WAS가 알아서 처리해줌

서블릿이란 웹페이지를 동적으로 생성하는 서버 측 프로그램 혹은 그 사양을 말함
서블릿은 웹서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종임
기존 서버는 정적인 자료(HTML, 사진, 글 등)만을 주고 받았음. 그러나 웹에 다양한 기능이 요구되며 정적인
자료뿐 아니라 사용자 요구에 맞춘 동적인 페이지들을 만들 필요가 생김 이를 위해 만들어진 것이 바로 서블릿임

쉽게 말해 서블릿은 클라이언트의 요청에 맞춰 동적인 결과를 만들어주는 자바 웹 프로그래밍 기술 이라 할 수 있음
이런 서블릿은 WAS의 서블릿 컨테이너 안에서 동작하게 됨

서블릿 특징
클라이언트의 요청에 동적으로 응답하는 웹 어플리케이션 컴포넌트
HTML을 사용하여 응답한다
JAVA의 쓰레드를 이용한다
Q.쓰레드를 사용하는 이유?
MVC 패턴의 컨트롤러 역할을 맡는다
Q.디스패치 서블릿과 관련이 있는지?
HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다
Q. javax.servlet.http.HttpServlet 클래스는 어떤 역할을 하는지?
HTTP 프로토콜 말고 다른 프로토콜을 지원하는 서비스도 있는지?
UDP보다 처리 속도가 느리다
Q. 왜 UDP보다 처리 속도가 느린지? 재 컴파일 등의 문제인지? 네트워크, 연결 구조상의 문제인지?
HTML 변경시 서블릿을 재 컴파일 해야 한다는 단점이 존재한다
Q. 왜 재컴파일 해야 되는지? 
입력되는 HTML 값이 달라지는데 컨테이너 기반 클래스 형태로 관리되고 있기 때문이라 생각



서블릿 컨테이너
서블릿 컨테이너는 서블릿을 담고 관리해주는 컨테이너임
서블릿 컨테이너는 구현되어 있는 서블릿 클래스의 규칙에 맞게 서블릿을 관리하며 
클라이언트의 요청을 받으면 httpServeletRequest와 HttpServletResponse
객체를 생성하여 post,get 여부에 따라 동적인 페이지를 생성하여 응답한다.

서블릿 컨테이너는 다음과 같은 기능을 함
1. 서블릿 생명주기 관리
서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리함. 
서블릿 클래스를 로딩하여 인스턴스화하고,
초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작함
또한 서블릿의 생명이 다하면 가비지 컬렉션을 통해 메모리에서 제거함

2. 통신 지원
서블릿 컨테이너는 웹 서버와 소켓을 만들어서 클라이언트의 요청을 받고 응답할 수 있는 
통신을 지원해 줌
통신을 하기 위한 listen, accept 등의 과정을 API로 제공하여 복잡한 과정을 생략해주기 때문에
개발자가 비즈니스 로직 개발에 집중할 수 있게 도와줌

3. 멀티쓰레드 지원 및 관리
서블릿 컨테이너는 클라이언트의 요청을 받을 때마다 새로운 자바 스레드를 생성함
따라서 동시에 여러 요청이 들어와도 멀티쓰레딩 환경에서 동시다발적인 작업을 관리할 수 있음

4. 선언적인 보안 관리
서블릿 컨테이너는 보안 관련 기능을 제공하기 때문에 개발자는 서블릿에 보안 관련 메서드를 구현하지 않아도 됨


추가로 연관해서 궁금한 키워드들
포워드 프록시, 리버스 프록시란?

http1.0과 1.1의 차이
2.0과 3.0차이
웹서버와 was의 차이
템플릿 엔진, jsp, thymeleaf란? 서버 사이트 템플릿엔진 vs 클라이언트 사이드 템플릿 엔진

<<<<<<< HEAD
캐시 종류?

인덱스 종류?

인덱스 삽입 삭제속도?

인덱스 빠른 이유

데이터베이스 튜닝방법

한번에 몇개 로우 가져오는지

테스트 방법
통합테스트란?
테스트 더블이란?
도커 푸시 


스프링 부트는 다음 그림에서 보듯 각 계층이 양 옆의 계층과 통신하는 구조를 따름.
여기서 계층이라는 단어가 조금 낯설게 느껴질 수 있는데, 계층이라는 것은 각자의 역할과 책임이 있는 어떤 소프트웨어의 구성 요소를 의미함.
각 계층은 서로 소통할 수 있지만 다른 계층에 직접 간섭하거나 영향을 미치지는 않음.

프레젠테이션, 비즈니스, 퍼시스턴스 계층이 있음.
컨트롤러 / 비즈니스/ 퍼시스턴스

프레젠테이션 계층
HTTP 요청을 받고 이 요청을 비즈니스 계층으로 전송하는 역할을 함. 컨트롤러가 바로 프레젠테이션 계층의 역할을 함
컨트롤러는 앞서 살펴본 TestController 클래스와 같은 것을 말함.

비즈니스 계층
모든 비즈니스 로직을 처리함, 비즈니스 로직이란 서비스를 만들기 위한 로직을 말함. 쉽게 말해 웹사이트에서 벌어지는 모든 작업, 이를테면 주문 서비스라고 한다면 주문 개수, 가격 등
데이터를 처리하기 위한 로직, 주문 처리를 하다 발생하는 예외 처리 로직, 주문을 받거나 취소하는 것 같이 프로세스를 구현하기 위한 로직등을 생각하면 됨. 서비스가 비즈니스 계층의 역할을 함.

퍼시스턴스 계층
모든 데이터베이스 관련 로직을 처리함. 데이터베이스에 접근하는 DAO 객체를 만들수도 있음. DAO는 데이터베이스 계층과 상호작용하기 위한 객체라고 이해하면 됨
리포지토리

main
실제 코드를 작성하는 공간, 프로젝트 실행에 필요한 소스 코드나 리소스 파일을 모두 이 폴더 안에 들어 있음



@AutoConfigureMockMCV
MockMvc를 생성하고 자동으로 구성하는 어노테이션
어플리케이션을 서버에 배포하지 않고도 테스트용 MVC 환경을 만들어 요청및 전송, 응답 기능을 제공하는 유틸리티 클래스임
즉, 컨트롤러를 테스트할 때 사용되는 클래스임

200ok isOk()
201 created isCreated()
400 Bad request isBadRequest()
403 forbidden isForbidden()
404 not found isNotFound()
400번대오류 is4xxClientError()
500 interan server error  isInternalServerError()
500번대 응답코드 is5xxServerError()

test
프로젝트의 소스 코드를 테스트할 목적의 코드나 리소스 파일이 들어 있음.

build.gradle
빌드를 설정하는 파일임

setting.gradle
빌드할 프로젝트의 정보를 설정하는 파일



테스트 코드란?
given - when - then
테스트 코드를 세단계로 구분해 작성하는 패턴
given은 테스트 실행을 준비하는 단계
when은 테스트를 진행하는 단계
then 은 테스트 결과를 검증하는 단계

테스트 방식을 구분할 수 잇는 애너테이션을 제공
@Test 애너테이션으로 메서드를 호출할 때마다 새 인스턴스를 생성, 독립 테스트 가능
예상 결과를 검증하는 어설션 메서드 제공
사용 방법이 단순, 테스트 코드 작성 시간이 적음


JPA와 하이버네이트?
자바에서는 JPA를 표준으로 사용함
JPA는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스인데, 인터페이스이므로 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야함
대표적으로 하이버네이트를 많이 사용함. 하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크임. 내부적으로는 JDBC API를 사용함
하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하는데 있음.

영속성 컨텍스트란
엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특성이 있음. 영속성 컨텍스트는 JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간임.
데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있음.
영속성 컨텍스트에는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩이라는 특징이 있음.

1차캐시
영속성 컨텍스트는 내부에 1차 캐시를 가지고 있음. 이때 캐시의 키는 엔티티의 @Id 어노테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티임
엔티티를 조회하면 1차캐시에서 데이터를 조회하고 값이 있으면 반환함.
값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환함.
이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터 조회가능

쓰기지연
쓰기지연은 트랜젝션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜젝션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미함.
예를 들어 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜젝션을 커밋하는 시점에 3개의 쿼리를 한꺼번에 쿼리를 전송함. 이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스의 부담을 줄일 수 있음.

변경 감지
트랜젝션을 커밋하면 1차캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영함. 이를 통해 쓰기 지연과 마찬가지로 적당한 묶음
으로 쿼리를 요청할 수 있고, 데이터베이스 시스템의 부담을 줄일 수 있음.

지연 로딩
지연 로딩은 쿼리로 요청한 데이터를 어플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터부하를 줄임


=======
>>>>>>> aa058162fbea0d72d10e193ade496a1eac3e9ff8


